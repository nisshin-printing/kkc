;#===============================================================================
;# じょじょのＷｅｂ工房
;# 共通ライブラリ ver.1.02	Copyright 1997-2001 JoJo's Web Lab.
;#
;#	 File:	jscm.pl
;#	 URL: http://www.starwars.jp/web/		 Email: webmaster@starwars.jp
;#
;#	 このソフトはフリーソフトです。
;#	 改造・商用利用は自由ですが、再配布は禁止します。
;#	 利用の際の損害については一切保証いたしません。
;#===============================================================================
;# 更新履歴
;#
;# 2001/11/27	ver.1.02	海外サーバによる時差の計算を自動的に行えるようにした。
;# 2001/07/24	ver.1.01	メッセージサイズが大きすぎる場合のエラーメッセージを追加した。
;#							Content-Lengthヘッダの出力可否フラグを追加した。
;#							GETメソッド時のエラーメッセージが文字化けしていたのを修正した。
;# 2001/05/09	ver.1.00	初回リリース
;#
;#===============================================================================
package jscm;

# 本ライブラリのバージョン
$version   = '1.02';

# ライブラリ名
$libname   = 'jscm.pl';

#
# グリニッジ標準時からの時差
#
# 	日本では+9時間。海外サーバでもサマータイムを含めてこれで普通は吸収できるはずだが、
#	それでも誤差がある場合はここで補正する（秒単位）。
#
$difftime  = 9*60*60;

#
# Content-Lengthヘッダの出力フラグ
#
#	自動的に広告が挿入されるサーバで動かない場合はここを 0 にする
#
$cntlenflg = 1;

;#===============================================================================
;# ファイルの後ろからの読み込み
;#		引数：ファイル名, 行数, 配列のリファレンス
;#		戻値：なし
;#===============================================================================
sub tailFile
{
	my ($file, $num, $ref) = @_;
	my $size = 0;
	my $pos = 0;
	my $bufsize = 1024;
	my $buf = '';
	my $tmp = '';
	my @dat = ();
	open(FILE, $file) || outError(3, $file);
	eval { flock(FILE, 1); };
	binmode(FILE);
	$size = (-s FILE) / $bufsize;
	$pos += $size <=> ($pos = int($size));
	while ($pos--) {
		seek(FILE, $bufsize * $pos, 0);
		read(FILE, $buf, $bufsize);
		$buf .= $tmp;
		($tmp, @dat) = $buf =~ /[^\r\n]*\r?\n?/g;
		pop(@dat);
		unshift(@$ref, @dat);
		last if @$ref >= $num;
	}
	close(FILE);
	unshift(@$ref, $tmp);
	@$ref = @$ref[-$num .. -1] if (@$ref > $num);
}

;#===============================================================================
;# ファイル一覧の読み込み
;#		引数：ディレクトリ名, 配列のリファレンス, [拡張子]
;#		戻値：取得ディレクトリ数
;#===============================================================================
sub readDir
{
	my ($dir, $ref, $exp) = @_;
	my $cnt = 0;
	my @tmp = ();
	opendir(DIR, $dir) || outError(4, $dir);
	@tmp = readdir(DIR);
	foreach (@tmp) {
		next if ($exp && index($_, ".$exp") < 0);
		next if ($_ eq '.' || $_ eq '..');
		push(@$ref, $_);
		$cnt++;
	}
	closedir(DIR);
	return $cnt;
}

;#===============================================================================
;# ファイルの画面表示
;#		引数：ファイル名
;#		戻値：なし
;#===============================================================================
sub printFile
{
	my ($file) = @_;
	my $size;
	$size = (-s $file);
	print "Content-Length: $size\n" if ($cntlenflg);
	print "\n";
	open(FILE, $file) || outError(3, $file);
	eval { flock(FILE, 1); };
	print $_ while (<FILE>);
	close(FILE);
}

;#===============================================================================
;# 日付文字列の作成
;#		引数：フォーマット, [time変数], [時差]
;#		戻値：日付文字列
;#===============================================================================
sub makeDate
{
	my ($fmt, $tt, $diff) = @_;
	$tt = time unless ($tt);
	$diff *= 3600;
	my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = gmtime($tt + $difftime + $diff);
	$year += 1900;
	$mon  = sprintf("%02d", ++$mon);
	$mday = sprintf("%02d", $mday);
	$hour = sprintf("%02d", $hour);
	$min  = sprintf("%02d", $min);
	$day  = ('日','月','火','水','木','金','土')[$wday];
	$fmt =~ s/yyyy/$year/;
	$fmt =~ s/mm/$mon/;
	$fmt =~ s/dd/$mday/;
	$fmt =~ s/w/$day/;
	$fmt =~ s/hh/$hour/;
	$fmt =~ s/nn/$min/;
	return $fmt;
}

;#===============================================================================
;# フォームのデコード
;#		引数：ハッシュのリファレンス, [GET許容フラグ], [文字コードセット]
;#		戻値：なし
;#===============================================================================
sub getForm
{
	my ($ref, $get, $charset) = @_;
	my $str  = '';
	if ($ENV{'REQUEST_METHOD'} eq 'POST') {
		read(STDIN, $str, $ENV{'CONTENT_LENGTH'});
	} else {
		$str = $ENV{'QUERY_STRING'} if ($get);
	}
	foreach (split(/[&;]/, $str)) {
		my ($name, $value) = split(/=/);
		$value =~ tr/+/ /;
		$value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
		$value =~ tr/\t/ /d;
		jcode::convert(*value, $charset) if ($charset);
		$$ref{$name} = $value;
	}
}

;#===============================================================================
;# Last-Modifiedヘッダの書き込み
;#		引数：ファイルパス
;#		戻値：出力すべきLast-Modifiedヘッダの値
;#===============================================================================
sub getLastModified
{
	my ($file) = @_;
	my ($mtime, $day, $mon);
	my $last = '';
	($mtime) = (stat($file))[9];
	my ($gsec, $gmin, $ghour, $gmday, $gmon, $gyear, $gwday, $gyday, $gisdst) = gmtime($mtime);
	$day = ('Sun','Mon','Tue','Wed','Thu','Fri','Sat')[$gwday];
	$mon = ('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec')[$gmon];
	$last = sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
			$day, $gmday, $mon, $gyear+1900, $ghour, $gmin, $gsec);
	return $last;
}

;#===============================================================================
;# 許可するHTMLタグの展開
;#		引数："/"区切りの許可タグ文字列, 許可タグ一覧のリファレンス
;#		戻値：なし
;#===============================================================================
sub getTag
{
	my ($str, $ref) = @_;
	$str =~ tr/A-Z/a-z/;
	@$ref = split(/\//, $str);
}

;#===============================================================================
;# HTMLタグのチェック
;#		引数：タグ入り文字列, 許可タグ一覧のリファレンス
;#		戻値：変換後文字列
;#===============================================================================
sub checkTag
{
	my ($str, $ref) = @_;
	$$str =~ s/&/&amp;/g;
	$$str =~ s/"/&quot;/g;
	$$str =~ s/</&lt;/g;
	$$str =~ s/>/&gt;/g;
	foreach (@$ref) {
		$$str =~ s|&lt;$_&gt;|<$_>|gi;
		$$str =~ s|&lt;$_(\s+(.*?))&gt;|<$_$1>|gi;
		$$str =~ s|&lt;/(\s*$_\s*)&gt;|</$1>|gi;
		1 while $$str =~ s|(<$_\s+.+)&quot;(.+>)|$1"$2|g;
	}
}

;#===============================================================================
;# 文字列中の改行コードを "\n" に変換
;#		引数：文字列のリファレンス
;#		戻値：なし
;#===============================================================================
sub encodeBr
{
	local($ref) = @_;
	$$ref =~ s/\\/\\\\/g;
	$$ref =~ s/\x0d\x0a/\\n/g;
	$$ref =~ s/\x0d/\\n/g;
	$$ref =~ s/\x0a/\\n/g;
}

;#===============================================================================
;# 文字列中の "\n" を改行コードに変換
;#		引数：文字列のリファレンス
;#		戻値：なし
;#===============================================================================
sub decodeBr
{
	local($ref) = @_;
	$$ref =~ s/\\\\/\0/g;
	$$ref =~ s/\\n/\n/g;
	$$ref =~ s/\0/\\/g;
}

;#===============================================================================
;# 文字列中のURL、メールアドレスをリンクに変換
;#		引数：文字列のリファレンス
;#		戻値：なし
;#===============================================================================
sub autoLink
{
	local($ref) = @_;
	$$ref =~ s/([^="',;]|^)((http|https|ftp):\/\/[\w\.\/\-+#?~&%=^\@:;]+)(["',]*)/$1<a href="$2">$2<\/a>$4/ig;
	$$ref =~ s/([\w\+-\.]+@[\w\+-]+\.[\w\+\.-]+)/<a href="mailto:$1">$1<\/a>/ig;
}

;#===============================================================================
;# 文字列中の引用部分をマークアップする
;#		引数：文字列のリファレンス
;#		戻値：なし
;#===============================================================================
sub markQuote
{
	my ($ref) = @_;
	my $buf = '';
	my @tmp = ();
	@tmp = split(/\n/i, $$ref);
	foreach (@tmp) {
		$_ =~ s/(^( |　)*(&gt;|＞).*$)/<q>$1<\/q>/;
		$_ =~ s/^( |　)*>(.*$)/<q>$1&gt;$2<\/q>/;
		$buf .= "$_\n";
	}
	$$ref = $buf;
}

;#===============================================================================
;# 文字列のURLエンコード
;#		引数：文字列のリファレンス
;#		戻値：なし
;#===============================================================================
sub encodeString
{
	local($ref) = @_;
	$$ref =~ s/(\W)/sprintf("%%%02X", unpack("C", $1))/eg;
}

;#===============================================================================
;# 文字列のURLデコード
;#		引数：文字列のリファレンス
;#		戻値：なし
;#===============================================================================
sub decodeString
{
	local($ref) = @_;
	$$ref =~ s/%([0-9A-Fa-f][0-9A-Fa-f])/pack("C", hex($1))/eg;
}

;#===============================================================================
;# エラー画面の表示
;#		引数：[エラー番号/エラーメッセージ], [備考]
;#		戻値：なし
;#===============================================================================
sub outError
{
	my ($err, $etc) = @_;
	if	  ($err <	0) { $mes = "原因不明のエラーです。";										   }
	elsif ($err ==	1) { $mes = "パスワードが違います。";										   }
	elsif ($err ==	2) { $mes = "必要な情報（$etc）に不足があります。"; 						   }
	elsif ($err ==	3) { $mes = "ファイルエラーです。[$etc]";									   }
	elsif ($err ==	4) { $mes = "ディレクトリエラーです。[$etc]";								   }
	elsif ($err ==	5) { $mes = "二重投稿はできません。";										   }
	elsif ($err ==	6) { $mes = "使用禁止文字（ $etc ）が含まれています。"; 					   }
	elsif ($err ==	7) { $mes = "既に存在しています。"; 										   }
	elsif ($err ==	8) { $mes = "この操作は許可されていません。";								   }
	elsif ($err ==	9) { $mes = "管理コードが違います。";										   }
	elsif ($err == 10) { $mes = "不正な指定です。（$etc）"; 									   }
	elsif ($err == 11) { $mes = "書込み禁止モードになっています。"; 							   }
	elsif ($err == 12) { $mes = "GETメソ\ッドによる書き込みが禁止されています。";				   }
	elsif ($err == 13) { $mes = "送信元URLが不正です。";										   }
	elsif ($err == 14) { $mes = "メッセージが長すぎます。${etc}byte以下にしてください。";		   }
	elsif ($err == 99) { $mes = "$libname のバージョンが違います。ver.$etc以降をご利用ください。"; }
	else			   { $mes = $err; }

print <<"EOF";

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html40/strict.dtd">
<html>
<head>
<title>エラー</title>
</head>
<body>
<p>$mes<br>ブラウザのBackボタンでお戻りください。</p>
</body>
</html>
EOF

	exit(-1);
}

1;

;# end_of_file
